# DB

## RDBMS
  - テーブルごとにデータを分けて保存・管理するデータベースシステム
    - MySQL
    - OracleDB
    - PostgreSQL

## テーブル(エンティティ)
  - 行：レコード
  - 属性：絡む
  - 値：フィールド

## 主キー(Primary Key)
  - レコードを一意に特定するキー
    - 重複しない
    - 変更しない
  - データベースのデーブルでは同じレコードは重複して保持しない

## 外部キー(Foreign Key)
  - 他のテーブルと結合するために使用するキー

# 正規化

## 非正規形
  - 行と列のデータが1対1とならない状態

## 第1正規化
  - 行と列のデータが1対1の状態とする
  - またレコードを一意に特定する主キーを選定

## 第2正規化
  - 主キーの一部に従属している属性を別テーブルに分ける
  - 部分関数従属を取り除く処理

### 部分関数従属
  - 店鋪ID、商品IDのどちらか一方の属性によって特定される属性（店舗名、商品名など）
    - 主キーの一部によって決まるもの

### 完全関数従属
  - 主キー（店鋪ID、商品IDの二つの属性）によって一意に特定される属性（数量）
    - 主キー全体を通して特定するもの

## 第3正規化
  - 主キー以外の属性に従属している属性を別テーブルに分ける

### 推移的関数従属
  - 主キー以外の属性に関数従属している属性のこと

## ER図
  - テーブル（エンティティ）の関係を可視化するための記法

### IE（Information Engineering）
  - ER図に置いてテーブルの関係を表す代表的な記法
  - テーブル同士のレコード数はカーディナりティと呼ぶ

#### カーディナりティ
  - 多
  - 0
  - 1

## SQL(Structured Query Language)
  - DBを操作するために使用する言語
  - DBに対する命令（ステートメント）を記述するための言語
    - ＝クエリ

### SQLの種類
  - DDL(Data Definition Language)
    - データ定義言語
  - DML(Data Manipulation Language)
    - データ操作言語
  - DCL(アクセス制限)、TCL（トランザクション制御）

#### データ定義言語（DDL）
  - DBオブジェクトの定義に使用
  - DBオブジェクトの例
    - テーブル
    - インデックス
    - ファンクション
    - トリガーなど

#### データ操作言語（DML）
  - テーブルデータの操作に使用
  - データの操作の例
    - 取得
    - 更新
    - 削除
    - 挿入など

### DB操作
  - DB作成

```
CREATE database test_db;
```

  - DB削除

```
DROP database test_db;
```

### デーブル操作
  - テーブルの作成
  - コメントの用途は和訳（が多い）

```
CREATE table テーブル名 (
  カラム名 データ型 default デフォルト値 制約 comment 'コメント',
  ...,
  表制約
) ENGINE = [INNODB | MyISAM]
```

  - 例

```
CREATE table test_db.test_table (
	id int(6) unsigned default 0 comment 'ID',
	val varchar(20) default 'hello' comment '値'
);
```

  - テーブルの削除

```
DROP table test_db.test_table;
```

  - テーブル表示

```
desc test_db.test_table;
show full columns from test_db.test_table;
show CREATE table test_db.test_table;
```

  - テーブルの選択

```
use test_db;
select database();
```

### データ型
  - INT：整数値
  - FLOAT：浮動小数点
    - ※正の値に限定する場合はunsignedを使用
  - DATATIME：日時
  - TIMESTAMP：日時
  - CHAR：固定長文字列
  - VARCHAR：可変長文字列
  - BLOB：バイナリデータ（画像や音声、動画など）

### 制約
  - UNIQUE：一意制約
  - NOT NULL：NOT NULL制約
  - PRIMARY KEY：主キー制約
  - FOREIGN KEY：外部キー制約
  - CHECK制約：チェック制約（MySQL8.0）

### 複合主キー

```
CREATE table test_db.test_table (
	key1 int,
	key2 int,
	primary key (key1, key2)
);
```

### Auto increment
  - 自動で採番
  - indexとは検索を高速化する仕組み
  - 一つのテーブルに一つしか付与できない
  - default値を設定することはできない

### テーブル定義の変更

```
alter table test_db.test_table
add column key2 varchar(20) not null,
add column key3 varchar(20) not null;

alter table test_db.test_table
add column key4 varchar(20) after key2;

alter table test_db.test_table
add column key5 varchar(20) first;

alter table test_db.test_table
modify column key5 int not null;

alter table test_db.test_table
drop column key5;

alter table test_db.test_table
modify column key1 int(11) NOT NULL;

alter table test_db.test_table
drop primary key;

show create table test_db.test_table;
```


## 外部キーの作成
  - 注意)
    - 型情報は合わせる
    - インデックスの自動付与
      - 既に有効なキーが存在する場合には作成しない
      - 例：複合主キーの一番最初はインデックスが作成されない

### ON DELETE
  - レコードが削除された際のアクション

### ON UPDATE
  - レコードが更新された際のアクション

### CASCADE
  - 親テーブルの行を削除または更新し、子テーブル内の一致する行を自動的に削除または更新する

### RESTRICT
  - 親テーブルに対する削除または更新操作を拒否する
  - ON DELETEまたはON UPDATE句を省略することと同義


```
alter table テーブル名
add constraint 制約名（※削除する際に使用）
foreign key (対象のキー名)
    references 親テーブル名(テーブルキー名)
    on update cascade
    on delete restrict; (省略可)

```

## トランザクションテーブルとマスタテーブルの識別

### トランザクションテーブル
  - アプリからデータを頻繁に挿入、更新するようなテーブル
  - エントリーテーブルとも呼ぶ
    - 例）オーダー情報、顧客情報、請求情報など
  - 先頭にENT、TXN、TRNなどをつける場合が多い

### マスタテーブル
  - 参照値を保持する用のテーブル
  - アプリからは基本的に値を挿入、変更しない
    - 例) 商品一覧、店鋪一覧
  - 先頭にMSTとつけることが多い

#### 論理フラグの導入（delete_flg）
  - レコードの有効性を識別するためのフラグ
    - 例）delete_flg = 1の場合には無効レコードとして使用

#### 更新日、更新者の導入（updated_at、updated_by）
  - レコードがいつ、誰によって変更されたのかの証跡を保持するための属性


```
use test_db;

DROP table stocks;
DROP table products;
DROP table shops;
DROP table prefs;

create table mst_products (
	id int(10) unsigned auto_increment primary key,
	name varchar(20) not null,
	delete_flg int(1) not null default 0,
	updated_at timestamp default current_timestamp on update current_timestamp,
	updated_by varchar(20) not null
);

create table mst_prefs (
	id int(2) unsigned auto_increment primary key,
	name varchar(10) not null,
	delete_flg int(1) not null default 0,
	updated_at timestamp default current_timestamp on update current_timestamp,
	updated_by varchar(20) not null
);

create table mst_shops (
	id int(10) unsigned auto_increment primary key,
	name varchar(50) not null,
	pref_id int(2) unsigned not null,
	delete_flg int(1) not null default 0,
	updated_at timestamp default current_timestamp on update current_timestamp,
	updated_by varchar(20) not null,
	constraint fk_pref_id
		foreign key(pref_id)
		references mst_prefs(id)
		on update cascade
);

create table txn_stocks (
	product_id int unsigned,
	shop_id int unsigned,
	amount int unsigned not null,
	delete_flg int(1) not null default 0,
	updated_at timestamp default current_timestamp on update current_timestamp,
	updated_by varchar(20) not null,
	primary key(product_id, shop_id),
	constraint fk_product_id
		foreign key (product_id)
		references mst_products(id)
		on update cascade,
	constraint fk_shop_id
		foreign key (shop_id)
		references mst_shops(id)
		on update cascade
);

```

## DML操作

### レコードの挿入

  - 単一レコードの挿入

```
insert into テーブル名（属性1、属性2）values ("値1", "値2");

```

例
```
INSERT into test_db.mst_prefs(name, updated_by) values('北海道', 'nagatak');

```

  - 複数レコードの挿入

```
insert into テーブル名（属性1、属性2）values （値1、値2）,
（値1、値2）,
（値1、値2）,
（値1、値2）;

```

例

```
INSERT into test_db.mst_prefs(name, updated_by) values('山形', 'nagatak'),
('青森', 'nagatak');

```

### レコードの取得

```
select 取得したい属性　[as label] from テーブル名 [as label]

```

#### 取得したい属性：
  - *：全ての属性を取得
  - distinct：重複レコードを省く
  - as：列ラベルの変更（asは省略可能）

```
select COUNT(*) as "件数" from test_db.mst_prefs as mp
```

```
select DISTINCT name "都道府県名" from test_db.mst_prefs as mp

```

#### auto_incrementの初期化
  - 例

```
alter table test_db.mst_prefs auto_increment = 1;
```

### 条件句
  - =：一致

```
SELECT * from test_db.txn_stocks
WHERE product_id = 1;

```

  - <>, !=：非一致

```
SELECT * from test_db.txn_stocks
WHERE product_id <> 1;

SELECT * from test_db.txn_stocks
WHERE product_id != 1;
```

  - >, >=, <, >, <=：数値の比較

```
SELECT * from test_db.txn_stocks
WHERE amount >= 60;
```

  - A and B：AかつB

```
SELECT * from test_db.txn_stocks
WHERE product_id =1 and shop_id =1;

```

  - A or B：AまたはB

```
SELECT * from test_db.txn_stocks
WHERE product_id =1 or shop_id =1;

```

  - ()：条件をくくる

```
SELECT * from test_db.txn_stocks
where (product_id=1 and shop_id=1)
or (product_id=2 and shop_id=2);
```

  - like：%で部分一致検索

```
SELECT * FROM test_db.mst_shops
WHERE name like '店鋪%';
```

  - in：いずれかの値に一致

```
SELECT * FROM test_db.mst_shops
WHERE name IN ('店鋪A', '店鋪B');
```

  - not in：いずれの値にも一致しない

```
SELECT * FROM test_db.mst_shops
WHERE name NOT IN ('店鋪A', '店鋪B');
```

  - between A and B：AからBの値

```
SELECT * FROM test_db.txn_stocks
WHERE amount BETWEEN 60 AND 100;
```

  - is not null：null以外に一致

```
SELECT * FROM test_db.txn_stocks
WHERE amount is NOT NULL;

```

  - is null：nullに一致

```
SELECT * FROM test_db.txn_stocks
WHERE amount is NULL;
```

#### 並べ替え
  - order by
    - asc（昇順）がデフォルト（省略可能）

```
SELECT * FROM test_db.txn_stocks
order by amount DESC;

SELECT * FROM test_db.txn_stocks
where amount > 50
order by amount DESC;

SELECT * FROM test_db.txn_stocks
order by product_id desc,
shop_id asc;
```

#### limitとoffset
  - limit：取得レコード数の制御
  - offset：取得開始位置の決定
  - offsetを省略した場合は、記載順が逆になる

```
SELECT * FROM test_db.txn_stocks
order by product_id desc,
shop_id asc
limit 2 offset 2;

SELECT * FROM test_db.txn_stocks
order by product_id desc,
shop_id asc
limit 1,2;
```

### テスト
  - '北海道', '青森'のidを取得してみよう

```
SELECT id from test_db.mst_prefs
WHERE name in ('北海道', '青森');
```

  - amount が 60 ~ 80 のレコードのshop_idを取得してみよう。

```
SELECT shop_id from test_db.txn_stocks
WHERE amount BETWEEN 60 AND 80;
```

  - amount が 50 以下のレコード数を取得してみよう。

```
SELECT count(*) from test_db.txn_stocks
WHERE amount <= 50;
```

  - 商品名が '椅子' 以外のname属性の値を商品名というラベルで取得してみよう。

```
SELECT name "商品名" from test_db.mst_products
where name <> '椅子';
```

  - shop_idが2かつproduct_idが1のレコードの更新日時と更新者を取得してみよう。

```
SELECT updated_at, updated_by from test_db.txn_stocks
WHERE shop_id =2 AND product_id = 1;
```

  - shop_idが2かつamountが70より大きい
  - または、shop_idが3かつamountが70より大きいレコードを取得してみよう。

```
SELECT * from test_db.txn_stocks
WHERE (shop_id=2 and amount>70) OR (shop_id=3 and amount >70);
```

  - 店舗名に A が含まれる店舗のpref_idを都道府県IDというラベル取得してみよう。

```
SELECT pref_id "都道府県ID" from test_db.mst_shops
WHERE name like '%A%';
```

  - shop_id が 2 のレコードを在庫数（amount）が多い順に取得してみよう。

```
SELECT * FROM test_db.txn_stocks
WHERE shop_id = 2
ORDER BY amount DESC;
```

  - 在庫数が上から２番目に多いレコードを取得してみよう。


```
SELECT * FROM test_db.txn_stocks
order by amount DESC
limit 1 offset 1;
```

### データの更新
  - 書き方
  - 更新するときはselect文で確認してから行う
  - cascade制約がある場合、参照先のテーブルで変更があった場合に自動的に参照先に会うように変更される

```
update テーブル名 set 属性1 = 値1, ... where 条件
```

```
update test_db.txn_stocks set amount = 50
WHERE product_id = 1 and shop_id =1;
```

## テーブルの結合
  - 内部結合(inner join)
    - 2つのテーブルを結合した際に両テーブルに存在するレコードを返す
    - 2つのテーブルの重なる部分が対象

  - 左外部結合(left join)
    - 2つのテーブルを結合した際に左側テーブルに存在するレコードを返す
    - テーブルAが対象

  - 右外部結合(right join)
    - 2つのテーブルを結合した際に右側テーブルに存在するレコードを返す
    - テーブルBが対象

  - 外部結合(outer join)
    - 条件に当てはまる2つのテーブルの全てのレコードを返す

### 内部結合

```
select * from テーブル1
inner join テーブル2
on テーブル1.値が一致する属性 = テーブル2.値が一致する属性;
```

```
select * from test_db.mst_shops ms
inner join test_db.mst_prefs mp
on ms.pref_id = mp.id;
```

```
select ms.name "店鋪名", mp.name "都道府県名" from test_db.mst_shops ms
inner join test_db.mst_prefs mp
on ms.pref_id = mp.id;
```

```
1	店鋪A	1	0	2021-07-12 08:11:19	nagatak	1	北海道	0	2021-07-10 21:54:47	nagatak
2	店鋪B	2	0	2021-07-11 10:48:23	nagatak	2	青森	0	2021-07-10 21:54:47	nagatak
3	店鋪C	3	0	2021-07-11 10:48:23	nagatak	3	岩手	0	2021-07-10 21:54:47	nagatak
```

### 外部結合

```
select * from 左テーブル
left join 右テーブル
on 左テーブル.値が一致する属性 = 右テーブル.値が一致する属性;
```

  - 上のSQlは左外部結合であり、左側のテーブルの値は全て持ってくる。対して結合先の右テーブルでは、左側テーブルに合わせて値をとってくる

```
SELECT mp.name "都道府県名", ms.name "店舗名"
from test_db.mst_shops ms
right join test_db.mst_prefs mp
on ms.pref_id = mp.id;
```

  - 上記は右外部結合

### 理解度チェック

```
select * from test_db.txn_stocks ts
inner join test_db.mst_shops ms
on ts.shop_id = ms.id;

select ms.name "店舗名", ts.product_id "商品ID", ts.amount "在庫数"
from test_db.txn_stocks ts
inner join test_db.mst_shops ms
on ts.shop_id = ms.id
order by ms.name;

select ms.name "店舗名", mp.name "商品名", ts.amount "在庫数"
from test_db.txn_stocks ts
inner join test_db.mst_shops ms
on ts.shop_id = ms.id
inner join test_db.mst_products mp
on ts.product_id = mp.id
order by ms.name;

select ms.name "店舗名", mpr.name "都道府県名", mp.name "商品名", ts.amount "在庫数"
from test_db.txn_stocks ts
inner join test_db.mst_shops ms
on ts.shop_id = ms.id
inner join test_db.mst_products mp
on ts.product_id = mp.id
inner join test_db.mst_prefs mpr
on mpr.id = ms.pref_id
order by ms.name;
```

## ACID特性 トランザクション

### トランザクション
  - 一連のSQL処理のグループのこと
  - SQLはDMLに限る

### ACID特性
  - トランザクション処理で担保される4つの要素の頭文字
    - Atomicity（原子性）
    - Consistency（一貫性）
    - Isolation（独立性）
    - Durability（永続性）

### Atomicity
  - SQLが全て成功、もしくは全て失敗することが保証されていること

### Consistency
  - トランザクションの結果が整合性を保つことが保証されること
  - 外部キー制約のCASCADEやトリガーなどによる値の変更もcommit、rollbackによって整合性が担保されること

### Isolation
  - トランザクション処理中の状態は他のセッションから独立していることが保証されていること

### Durability
  - トランザクション完了後のデータは永続的にストレージに保持されることが保証されていること


### ACID実践

```
-- セッションA
start transaction

INSERT into test_db.txn_stocks(product_id, shop_id, amount, updated_by)
values (1, 3, 20, 'nagatak');

-- 同一セッション内の確認
select * from test_db.txn_stocks
where (product_id = 1 and shop_id = 1)
or (product_id=1 and shop_id=3);

UPDATE  test_db.txn_stocks set amount = 1000
WHERE product_id = 1 and shop_id =1;

-- 成功
commit;

-- 失敗
 rollback;
```

## ロックとデッドロック
### ロック
  - データを更新する前に行、またはテーブルを他のセッションから更新させないようにすること
    - 例：テーブルロック、行ロック

### デッドロック
  - 複数セッションがそれぞれロック解除待ちを行い、処理が完了しない状態

```

=====================================
2021-07-14 08:00:06 0x30b82c000 INNODB MONITOR OUTPUT
=====================================
Per second averages calculated from the last 21 seconds
-----------------
BACKGROUND THREAD
-----------------
srv_master_thread loops: 203 srv_active, 0 srv_shutdown, 62238 srv_idle
srv_master_thread log flush and writes: 62441
----------
SEMAPHORES
----------
OS WAIT ARRAY INFO: reservation count 1137
OS WAIT ARRAY INFO: signal count 989
RW-shared spins 0, rounds 414, OS waits 205
RW-excl spins 0, rounds 1508, OS waits 27
RW-sx spins 4, rounds 120, OS waits 4
Spin rounds per wait: 414.00 RW-shared, 1508.00 RW-excl, 30.00 RW-sx
------------------------
LATEST FOREIGN KEY ERROR
------------------------
2021-07-10 10:36:14 0x30b870000 Error in foreign key constraint of table test_db/#sql-1749b_27d:

foreign key (shop_id)
references shopss(id)
on UPDATE cascade
on DELETE restrict:
Cannot resolve table name close to:
(id)
on UPDATE cascade
on DELETE restrict
------------------------
LATEST DETECTED DEADLOCK
------------------------
2021-07-14 07:59:11 0x30b870000
*** (1) TRANSACTION:
TRANSACTION 29916, ACTIVE 43 sec starting index read
mysql tables in use 1, locked 1
LOCK WAIT 3 lock struct(s), heap size 1136, 2 row lock(s), undo log entries 1
MySQL thread id 937, OS thread handle 13078020096, query id 2738 localhost 127.0.0.1 root updating
/* ApplicationName=DBeaver 21.1.2 - SQLEditor <Script.sql> */ UPDATE test_db.txn_stocks set amount = 500
WHERE product_id = 1 and shop_id = 2
*** (1) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 371 page no 3 n bits 80 index PRIMARY of table `test_db`.`txn_stocks` trx id 29916 lock_mode X locks rec but not gap waiting
Record lock, heap no 3 PHYSICAL RECORD: n_fields 8; compact format; info bits 0
 0: len 4; hex 00000001; asc     ;;
 1: len 4; hex 00000002; asc     ;;
 2: len 6; hex 0000000074dd; asc     t ;;
 3: len 7; hex 39000001ea2346; asc 9    #F;;
 4: len 4; hex 000003e8; asc     ;;
 5: len 4; hex 80000000; asc     ;;
 6: len 4; hex 60ee1aa4; asc `   ;;
 7: len 7; hex 6e61676174616b; asc nagatak;;

*** (2) TRANSACTION:
TRANSACTION 29917, ACTIVE 27 sec starting index read
mysql tables in use 1, locked 1
3 lock struct(s), heap size 1136, 2 row lock(s), undo log entries 1
MySQL thread id 1350, OS thread handle 13078298624, query id 2740 localhost 127.0.0.1 root updating
/* ApplicationName=DBeaver 21.1.2 - SQLEditor <Script-1.sql> */ UPDATE test_db.txn_stocks set amount = 1000
WHERE product_id = 1 AND shop_id = 1
*** (2) HOLDS THE LOCK(S):
RECORD LOCKS space id 371 page no 3 n bits 80 index PRIMARY of table `test_db`.`txn_stocks` trx id 29917 lock_mode X locks rec but not gap
Record lock, heap no 3 PHYSICAL RECORD: n_fields 8; compact format; info bits 0
 0: len 4; hex 00000001; asc     ;;
 1: len 4; hex 00000002; asc     ;;
 2: len 6; hex 0000000074dd; asc     t ;;
 3: len 7; hex 39000001ea2346; asc 9    #F;;
 4: len 4; hex 000003e8; asc     ;;
 5: len 4; hex 80000000; asc     ;;
 6: len 4; hex 60ee1aa4; asc `   ;;
 7: len 7; hex 6e61676174616b; asc nagatak;;

*** (2) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 371 page no 3 n bits 80 index PRIMARY of table `test_db`.`txn_stocks` trx id 29917 lock_mode X locks rec but not gap waiting
Record lock, heap no 2 PHYSICAL RECORD: n_fields 8; compact format; info bits 0
 0: len 4; hex 00000001; asc     ;;
 1: len 4; hex 00000001; asc     ;;
 2: len 6; hex 0000000074dc; asc     t ;;
 3: len 7; hex 38000001f60fd8; asc 8      ;;
 4: len 4; hex 000001f4; asc     ;;
 5: len 4; hex 80000001; asc     ;;
 6: len 4; hex 60ee1a94; asc `   ;;
 7: len 7; hex 6e61676174616b; asc nagatak;;

*** WE ROLL BACK TRANSACTION (2)
------------
TRANSACTIONS
------------
Trx id counter 29919
Purge done for trx's n:o < 29919 undo n:o < 0 state: running but idle
History list length 0
LIST OF TRANSACTIONS FOR EACH SESSION:
---TRANSACTION 421932680909256, not started
0 lock struct(s), heap size 1136, 0 row lock(s)
---TRANSACTION 421932680907448, not started
0 lock struct(s), heap size 1136, 0 row lock(s)
---TRANSACTION 421932680906544, not started
0 lock struct(s), heap size 1136, 0 row lock(s)
---TRANSACTION 29916, ACTIVE 98 sec
3 lock struct(s), heap size 1136, 2 row lock(s), undo log entries 2
MySQL thread id 937, OS thread handle 13078020096, query id 2746 localhost 127.0.0.1 root starting
/* ApplicationName=DBeaver 21.1.2 - SQLEditor <Script.sql> */ -- deadlockの確認
show engine innodb status
--------
FILE I/O
--------
I/O thread 0 state: waiting for i/o request (insert buffer thread)
I/O thread 1 state: waiting for i/o request (log thread)
I/O thread 2 state: waiting for i/o request (read thread)
I/O thread 3 state: waiting for i/o request (read thread)
I/O thread 4 state: waiting for i/o request (read thread)
I/O thread 5 state: waiting for i/o request (read thread)
I/O thread 6 state: waiting for i/o request (write thread)
I/O thread 7 state: waiting for i/o request (write thread)
I/O thread 8 state: waiting for i/o request (write thread)
I/O thread 9 state: waiting for i/o request (write thread)
Pending normal aio reads: [0, 0, 0, 0] , aio writes: [0, 0, 0, 0] ,
 ibuf aio reads:, log i/o's:, sync i/o's:
Pending flushes (fsync) log: 0; buffer pool: 0
468 OS file reads, 4038 OS file writes, 1105 OS fsyncs
0.00 reads/s, 0 avg bytes/read, 0.38 writes/s, 0.24 fsyncs/s
-------------------------------------
INSERT BUFFER AND ADAPTIVE HASH INDEX
-------------------------------------
Ibuf: size 1, free list len 0, seg size 2, 0 merges
merged operations:
 insert 0, delete mark 0, delete 0
discarded operations:
 insert 0, delete mark 0, delete 0
Hash table size 34673, node heap has 0 buffer(s)
Hash table size 34673, node heap has 0 buffer(s)
Hash table size 34673, node heap has 0 buffer(s)
Hash table size 34673, node heap has 0 buffer(s)
Hash table size 34673, node heap has 0 buffer(s)
Hash table size 34673, node heap has 0 buffer(s)
Hash table size 34673, node heap has 0 buffer(s)
Hash table size 34673, node heap has 0 buffer(s)
0.00 hash searches/s, 0.00 non-hash searches/s
---
LOG
---
Log sequence number 9959971
Log flushed up to   9959971
Pages flushed up to 9959971
Last checkpoint at  9959962
0 pending log flushes, 0 pending chkp writes
665 log i/o's done, 0.14 log i/o's/second
----------------------
BUFFER POOL AND MEMORY
----------------------
Total large memory allocated 137428992
Dictionary memory allocated 123610
Buffer pool size   8191
Free buffers       7589
Database pages     602
Old database pages 216
Modified db pages  0
Pending reads      0
Pending writes: LRU 0, flush list 0, single page 0
Pages made young 0, not young 0
0.00 youngs/s, 0.00 non-youngs/s
Pages read 429, created 173, written 3177
0.00 reads/s, 0.00 creates/s, 0.00 writes/s
Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000
Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s
LRU len: 602, unzip_LRU len: 0
I/O sum[0]:cur[0], unzip sum[0]:cur[0]
--------------
ROW OPERATIONS
--------------
0 queries inside InnoDB, 0 queries in queue
0 read views open inside InnoDB
Process ID=95387, Main thread ID=13072355328, state: sleeping
Number of rows inserted 6262, updated 15, deleted 9, read 7098
0.00 inserts/s, 0.00 updates/s, 0.00 deletes/s, 0.00 reads/s
----------------------------
END OF INNODB MONITOR OUTPUT
============================

```


### Truncate テーブルの切り捨て
  - 特徴：
    - rollbackで戻せない
    - deleteより高速
    - where句は使用不可
    - auto_incrementは初期値となる

### システム変数
  - 値の取得
    - @@session.変数名：現在のセッション内での値を取得
    - @@local.変数名：@@sessionと同じ
    - @@global.変数名：サーバー上の値を取得
    - @@変数名：session -> global の順番で変数を取得
  - 値の変更
    - set session：現在のセッション内で有効
    - set Local：Sessionと同じ
    - set global：全てのセッション（サーバー全体）で有効（DB再起動まで）
      - ※省略した場合はセッション変数を変更

```
show global variables like '%auto%';

SELECT @@global.autocommit;

set session autocommit = 0;
```

- autocommitがオフの場合はstart transactionを流す必要はない


### TIMESTAMPとDATETIMEの違い
  - TIMESTAMP
    - 4 bytes
    - 1970-01-01 00:00:01 UTC to 2038-01-09 03:14:07
    - タイムゾーンを考慮
  - DATETIME
    - 5 bytes（旧バージョンでは8bytes）
    - 1000-01-01 00:00:00 to 9999-12-31 23:59:59
    - タイムゾーンを考慮しない

```
CREATE table test_date (
	dt datetime,
	ts timestamp
);

-- タイムゾーンの確認
 SELECT @@session.time_zone;

-- 現在時刻を挿入
 INSERT into test_date values (now(),now());

-- レコードの確認
 SELECT * FROM test_date;

-- タイムゾーンの変更
 set SESSION time_zone = "+1:00";
```

### ユーザの作成と確認

```
-- 現在ユーザの確認
 SELECT USER();

-- ユーザの作成
 CREATE user {ユーザ名}@{接続元のホスト先} identified by 'password';

 SELECT * from mysql.user;
```

### ユーザ権限の付与

```
-- 権限の付与
grant {権限名} on {対象のDBオブジェクト} to {ユーザ};

-- 全てのテーブルに対し、select可能
grant select on test_db.* to 'test_user'@'localhost';

-- お試し
grant all on test_db.* to 'test_user'@'localhost';
grant update, insert on test_db.* to 'test_user'@'localhost';
grant create, alter on test_db.* to 'test_user'@'localhost';

-- 権限確認
show grants for 'test_user'@'localhost';

-- 権限削除
revoke all on test_db.* from 'test_user'@'localhost';
```

### 文字コード
  - utf8
    - 3bytes
    - 一部、表示できない文字が存在する
  - utf8mb4
    - 4bytes
    - 絵文字などにも対応
  - ※MySQLの今後のバージョンでは、utf8が4bytesのutf8になり、3bytesのutf8を指定するときにutf8mb3を示す必要が生じる可能性がある

```
create table test_db.char_test (
	mb4 varchar(20) character set 'utf8mb4',
	mb3 varchar(20) character set 'utf8'
);

INSERT into test_db.char_test(mb4) values('😅');
INSERT into test_db.char_test(mb3) values('😅');

SELECT * FROM  test_db.char_test;
```

### collation 照合順序
  - 照合順序は文字列をどのように比較するかに影響する

#### utf8mb4_general_ci
  - 英字の大文字小文字が区別されない
  - 半角と全角小は区別する

#### utf8mb4_unicode_ci
  - 大文字小文字、全角半角、ひらがな・カタカナ、濁音・半濁音が区別されない

#### utf8mb4_bin
  - 全て区別

### インデックスとオプティマイザ
  - インデックスを使用することで高速に処理を完了できる
  - インデックスが使用されるケース
    - 値の比較（<）や等価（＝）
    - like '文字%'
      - 文字の前に%が入っている場合にはインデックスは使用されない
    - 表の結合時
    - order byによるソート
  - オプティマイザは実際にどのようにしてレコードを取得するかを決定する制御
    - インデックスを使うかどうか
    - データの件数や偏り、またはテーブルのカラム数によっても挙動が変わる
